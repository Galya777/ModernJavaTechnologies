Условие

Кампанията по записване на изборни дисциплини във ФМИ е в разгара си, но Ники е в голяма дилема. Всички яки курсове, които си е набелязал, по програма са в сряда, и за съжаление някои се застъпват като часове. Той си направи списък на желаните курсове с началния и крайния час на всеки (за простота, реши да ги представя с цели числа) и се опита да максимизира броя незастъпващи се курсове, които може да посещава. Ники тъкмо започваше да учи Java, затова реши да напише набързо една функция, която по даден масив с N елемента от масиви с по два елемента (представящи съответно стартовия и крайния час на дадения курс) да връща максималния възможен брой незастъпващи се курсове:

public static int maxNonOverlappingCourses(int[][] courses)

Функцията сложи в публичен клас, който без много да му мисли кръсти CourseScheduler и започна да експериментира.
Примери
Извикване 	Резултат
maxNonOverlappingCourses(new int[][]{{9, 11}, {10, 12}, {11, 13}, {15, 16}}) 	3
maxNonOverlappingCourses(new int[][]{{19, 22}, {17, 19}, {9, 12}, {9, 11}, {15, 17}, {15, 17}}) 	4
maxNonOverlappingCourses(new int[][]{{19, 22}}) 	1
maxNonOverlappingCourses(new int[][]{{13, 15}, {13, 17}, {11, 17}}) 	1
⚠️ Забележки

    Помисли, каква е сложността на използвания от теб алгоритъм и може ли да се оптимизира
    Използването на структури от данни, различни от масив, както и на компаратори, ламбда изрази и прочее не е позволено - задачата може и трябва да се реши с помощта на знанията от първата лекция от курса.
